<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JIAO GUOWEI</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JIAO GUOWEI">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="JIAO GUOWEI">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JIAO GUOWEI">
  
    <link rel="alternate" href="/atom.xml" title="JIAO GUOWEI" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JIAO GUOWEI</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">PERSON BLOG</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ziliao" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/17/ziliao/" class="article-date">
  <time datetime="2016-10-17T01:59:18.000Z" itemprop="datePublished">2016-10-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/17/ziliao/">ziliao</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ECMA内置的对象："><a href="#ECMA内置的对象：" class="headerlink" title="ECMA内置的对象："></a>ECMA内置的对象：</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Array Data Object String Number Boolean Function Errow RegExp</div><div class="line">前面9个也是内置的构造函数，它们继承它们各自的原型对象</div><div class="line">Math</div><div class="line">内置对象，直接继承Object.prototype</div></pre></td></tr></table></figure>
<h1 id="如何判断数据类型"><a href="#如何判断数据类型" class="headerlink" title="如何判断数据类型"></a>如何判断数据类型</h1><p><strong>typeof</strong><br>typeof运算符运算后有一个返回结果，这个结果它自身的数据类型是”string”<br>typeof 运算结果只有如下几种值：</p>
<blockquote>
<p>‘object’、’string’、’number’、’boolean’、’function’、’undefined’<br>typeof 内置的9大构造函数，都返回”function”类型<br>typeof Math 返回值为”object”<br>typeof无法判断null数据类型，反过来说typeof判断object类型数据可能有错误</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typeof null 结果为&quot;object&quot;</div><div class="line">typeof []的执行结果为&quot;object&quot;</div><div class="line">typeof function()&#123;&#125;的执行结果为&quot;function&quot;</div><div class="line">typeof undefine的执行结果为&quot;undefine&quot;</div></pre></td></tr></table></figure>
<h1 id="基本数据类型与引用数据类型的赋值问题"><a href="#基本数据类型与引用数据类型的赋值问题" class="headerlink" title="基本数据类型与引用数据类型的赋值问题"></a>基本数据类型与引用数据类型的赋值问题</h1><ul>
<li>基本数据类型赋的是具体的值</li>
<li>引用数据类型赋的是地址</li>
</ul>
<h1 id="数据类型转化"><a href="#数据类型转化" class="headerlink" title="数据类型转化"></a>数据类型转化</h1><blockquote>
<p>那些数据类型转化为布尔类型时为false<br><strong>0  undefine  null  NAN  “ “</strong><br>除上面五个之外所有的数据都转化成boolean类型时值为true<br>!!null </p>
</blockquote>
<h1 id="相等判断"><a href="#相等判断" class="headerlink" title="相等判断"></a>相等判断</h1><ul>
<li>=== 类型与值必须相等</li>
<li>== 会先进行数据类型转化再比较</li>
</ul>
<h3 id="数据类型转化的规律"><a href="#数据类型转化的规律" class="headerlink" title="数据类型转化的规律"></a>数据类型转化的规律</h3><ul>
<li>数字与非空类型比较，先转化为数字再比较</li>
<li>布尔与非空类型的比较，先转化数字再比较</li>
<li>任何数据与NaN比较，结果为false（NaN==NaN结果也为false）</li>
<li>null和非空类型比较，结果为false</li>
<li>null等于undefined</li>
<li>对象与字符串比较，对象先转化成字符串再比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[] 转化成数字为0，[]转化成boolean的值为false</div><div class="line">0==[] true</div><div class="line">true==[] false </div><div class="line">&#123;&#125;==&#123;&#125; false 对象比较的是地址</div><div class="line">“[object Object]”==&#123;&#125; true 因为Object.prototype.toString()的值为[object Object]</div><div class="line">[1,2]==&quot;1,2&quot; true</div></pre></td></tr></table></figure>
<h1 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h1><ul>
<li>&amp;&amp;从左到右依次转化为boolean类型，如果是false则返回对应的数据类型，如果一直没有找到则返回最后一个</li>
<li>||从左到右依次转化为boolean类型，如果是true则返回对应的数据类型，如果一直没有找到则返回最后一个</li>
</ul>
<h1 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h1><p>可以在函数中使用的关键字。通过它可以获取实参的个数。有length属性，是一个对象，也称伪数组，通过索引可以获取实参的值。</p>
<h1 id="伪数组"><a href="#伪数组" class="headerlink" title="伪数组"></a>伪数组</h1><p>不是数组，是个对象，拥有length属性，以下标存储的对象，统称为伪数组。</p>
<h1 id="错误抛出"><a href="#错误抛出" class="headerlink" title="错误抛出"></a>错误抛出</h1><p>throw “抛出一个错误”  后面代码不在执行</p>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><blockquote>
<p>本意判断一个对象是不是另一个构造函数的实例<br>运算符的规则，判断左边的对象的原型链结构中，是否存在右边构造函数的显示原型</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>对象 instanceof 构造函数 返回值为boolean值</p>
</blockquote>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><h2 id="函数的prototype属性（显示原型）"><a href="#函数的prototype属性（显示原型）" class="headerlink" title="函数的prototype属性（显示原型）"></a>函数的prototype属性（显示原型）</h2><blockquote>
<p>js提供的，能够让实例共享某些数据的解决办法</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>每个构造函数诞生的时候，都自带一个叫做prototype的属性，这个属性存储着一个对象地址，而实例可以无条件的访问里面的内容。<br>Person.prototype里面存储的东西，<br>就是为了让实例共享，<br>得到节省内存的目的</p>
</blockquote>
<p><strong>构造函数自身无法访问里面的东西</strong><br><strong>只有函数才拥有prottotype属性，因为只有函数才可以创造出实例</strong></p>
<h2 id="proto属性（隐示原型）"><a href="#proto属性（隐示原型）" class="headerlink" title="proto属性（隐示原型）"></a><strong>proto</strong>属性（隐示原型）</h2><blockquote>
<p>每一个对象都有一个<strong>proto</strong>属性。<br>通过构造函数创建的实例对象，都会带有一个<strong>proto</strong>属性，<br>这个属性的值与构造函数prototype属性的值一致，<br>都存储着同一个对象的地址。</p>
</blockquote>
<p><strong><br>对象的属性查找规则：<br><strong>proto</strong>相当是一个记录着宝藏存放的地址的属性；<br> 所有的对象都有这个属性，<br> 每当我们访问一个对象的属性或方法，<br> 那么首先会在自身去找，<br> 找不到就去顺着<strong>proto</strong>找宝藏，<br> 宝藏没有再继续顺序<strong>proto</strong>找下一个宝藏，<br> 直到终点。
 </strong></p>
<h1 id="老师总结"><a href="#老师总结" class="headerlink" title="老师总结"></a>老师总结</h1><h3 id="面向对象的概念"><a href="#面向对象的概念" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h3><ul>
<li>面向对象就是利用对象解决问题。</li>
<li>面向对象讲究的是，凡事不用自己亲力亲为。</li>
<li>面向对象离不开面向过程，相当于是对面向过程的封装。</li>
<li>面向对象一般应用与大型软件开发，使用了面向对象开发的大型软件就像是使用Xmind进行组织一样。</li>
</ul>
<h3 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h3><ul>
<li>就是对创建对象的过程进行了封装。</li>
<li>如果一个函数调用后，返回值是一个对象，那么就可以认为它是一个工厂函数。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>如果一个用来配合new关键字创建对象，那么就可以称呼这个函数为构造函数。</li>
</ul>
<h3 id="构造函数与普通函数的关系"><a href="#构造函数与普通函数的关系" class="headerlink" title="构造函数与普通函数的关系"></a>构造函数与普通函数的关系</h3><ul>
<li>构造函数与普通函数无异，本身就是一个东西。</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul>
<li>就是对一些具有相同特征与特性的对象的抽象描述。</li>
<li>在ES6之前，可以把构造函数看作是类。</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><ul>
<li>通过构造函数创建出来的对象就叫实例。</li>
<li>注：在口头描述上，实例指的是直系后代（在编程语言中，实例也指子孙后代）</li>
</ul>
<h5 id="实例的类型"><a href="#实例的类型" class="headerlink" title="实例的类型"></a>实例的类型</h5><ul>
<li>实例的类型就是构造函数的名字。</li>
</ul>
<h3 id="原型-amp-原型的作用"><a href="#原型-amp-原型的作用" class="headerlink" title="原型&amp;原型的作用"></a>原型&amp;原型的作用</h3><ul>
<li>原型是js提供的一个实现继承的机制。</li>
<li>原型就是为了让实例共享一些属性与方法，达到节省内存以及复用代码的目的。</li>
</ul>
<h5 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h5><ul>
<li>所有的函数默认都含有这个属性</li>
<li>作用：通过函数new出来的实例，都会继承这个属性所指向的对象</li>
<li>本质: prototype就是为了引导实例的<strong>proto</strong>属性值</li>
</ul>
<h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h5><ul>
<li>所有的对象都含有这个属性</li>
<li>访问一个对象的属性时，如果对象自身没有，就会到<strong>proto</strong>指向的对象中去查找。</li>
</ul>
<h5 id="new构造函数自动执行的4个步骤"><a href="#new构造函数自动执行的4个步骤" class="headerlink" title="new构造函数自动执行的4个步骤"></a>new构造函数自动执行的4个步骤</h5><ul>
<li>new会自动创建一个新对象(本质上就是开辟一块内存空间)</li>
<li>给新对象添加一个<strong>proto</strong>属性，该属性的值为(！当前！)构造函数prototype属性的值。</li>
<li>利用新对象调用构造函数(那么构造函数内的this就指向了新对象)</li>
<li>返回新对象的地址</li>
</ul>
<h3 id="属性查找规则"><a href="#属性查找规则" class="headerlink" title="属性查找规则"></a>属性查找规则</h3><ul>
<li>先找自身，自身没有，顺着<strong>proto</strong>属性查找指定的对象；</li>
<li>这个对象没有，继续顺着<strong>proto</strong>查找；</li>
<li>直到终点。</li>
</ul>
<h3 id="面向对象的概念-1"><a href="#面向对象的概念-1" class="headerlink" title="面向对象的概念"></a>面向对象的概念</h3><ul>
<li>面向对象就是利用对象解决问题。</li>
<li>面向对象讲究的是，凡事不用自己亲力亲为。</li>
<li>面向对象离不开面向过程，相当于是对面向过程的封装。</li>
<li>面向对象一般应用与大型软件开发，使用了面向对象开发的大型软件就像是使用Xmind进行组织一样。</li>
</ul>
<h3 id="工厂函数-1"><a href="#工厂函数-1" class="headerlink" title="工厂函数"></a>工厂函数</h3><ul>
<li>就是对创建对象的过程进行了封装。</li>
<li>如果一个函数调用后，返回值是一个对象，那么就可以认为它是一个工厂函数。</li>
</ul>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>如果一个用来配合new关键字创建对象，那么就可以称呼这个函数为构造函数。</li>
</ul>
<h3 id="构造函数与普通函数的关系-1"><a href="#构造函数与普通函数的关系-1" class="headerlink" title="构造函数与普通函数的关系"></a>构造函数与普通函数的关系</h3><ul>
<li>构造函数与普通函数无异，本身就是一个东西。</li>
</ul>
<h3 id="类-1"><a href="#类-1" class="headerlink" title="类"></a>类</h3><ul>
<li>就是对一些具有相同特征与特性的对象的抽象描述。</li>
<li>在ES6之前，可以把构造函数看作是类。</li>
</ul>
<h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><ul>
<li>通过构造函数创建出来的对象就叫实例。</li>
<li>注：在口头描述上，实例指的是直系后代（在编程语言中，实例也指子孙后代）</li>
</ul>
<h5 id="实例的类型-1"><a href="#实例的类型-1" class="headerlink" title="实例的类型"></a>实例的类型</h5><ul>
<li>实例的类型就是构造函数的名字。</li>
</ul>
<h3 id="原型-amp-原型的作用-1"><a href="#原型-amp-原型的作用-1" class="headerlink" title="原型&amp;原型的作用"></a>原型&amp;原型的作用</h3><ul>
<li>原型是js提供的一个实现继承的机制。</li>
<li>原型就是为了让实例共享一些属性与方法，达到节省内存以及复用代码的目的。</li>
</ul>
<h5 id="prototype-1"><a href="#prototype-1" class="headerlink" title="prototype"></a>prototype</h5><ul>
<li>所有的函数默认都含有这个属性</li>
<li>作用：通过函数new出来的实例，都会继承这个属性所指向的对象</li>
<li>本质: prototype就是为了引导实例的<strong>proto</strong>属性值</li>
</ul>
<h5 id="proto-1"><a href="#proto-1" class="headerlink" title="proto"></a><strong>proto</strong></h5><ul>
<li>所有的对象都含有这个属性</li>
<li>访问一个对象的属性时，如果对象自身没有，就会到<strong>proto</strong>指向的对象中去查找。</li>
</ul>
<h5 id="new构造函数自动执行的4个步骤-1"><a href="#new构造函数自动执行的4个步骤-1" class="headerlink" title="new构造函数自动执行的4个步骤"></a>new构造函数自动执行的4个步骤</h5><ul>
<li>new会自动创建一个新对象(本质上就是开辟一块内存空间)</li>
<li>给新对象添加一个<strong>proto</strong>属性，该属性的值为(！当前！)构造函数prototype属性的值。</li>
<li>利用新对象调用构造函数(那么构造函数内的this就指向了新对象)</li>
<li>返回新对象的地址</li>
</ul>
<h3 id="属性查找规则-1"><a href="#属性查找规则-1" class="headerlink" title="属性查找规则"></a>属性查找规则</h3><ul>
<li>先找自身，自身没有，顺着<strong>proto</strong>属性查找指定的对象；</li>
<li>这个对象没有，继续顺着<strong>proto</strong>查找；</li>
<li>直到终点。</li>
</ul>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><blockquote>
<p>一个对象可以使用另一个对象的东西，就叫继承。<br>一个对象可以使用本不属于自己的东西，就叫继承。<br>js中的原型就是对继承特性的实现。<br>下面记录的继承方式都是基于原型的，然后融入了一些程序猿自己的编程思想，从而引出了多种继承方式。</p>
</blockquote>
<h3 id="继承方式1-默认的原型继承-很常用"><a href="#继承方式1-默认的原型继承-很常用" class="headerlink" title="继承方式1 - 默认的原型继承( 很常用 )"></a>继承方式1 - 默认的原型继承( 很常用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype.value = 100;</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式2-覆写构造函数的显式原型-很常用"><a href="#继承方式2-覆写构造函数的显式原型-很常用" class="headerlink" title="继承方式2 - 覆写构造函数的显式原型( 很常用 )"></a>继承方式2 - 覆写构造函数的显式原型( 很常用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype = &#123;</div><div class="line">     value: 100</div><div class="line"> &#125;</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式3-给显式原型混入属性-很常用"><a href="#继承方式3-给显式原型混入属性-很常用" class="headerlink" title="继承方式3 - 给显式原型混入属性( 很常用 )"></a>继承方式3 - 给显式原型混入属性( 很常用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function extend(o1, o2) &#123;</div><div class="line">    for ( var key in o2 ) &#123;</div><div class="line">        o1[key] = o2[key];</div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line">var obj = &#123; add: function (a,b) &#123; console.log(a+b) &#125; &#125; </div><div class="line">function Fn() &#123;&#125;</div><div class="line">extend(Fn.prototype, obj);</div><div class="line">extend(Fn.prototype, &#123;</div><div class="line">    value: 100</div><div class="line">&#125;);</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式4-Object-create-很少用"><a href="#继承方式4-Object-create-很少用" class="headerlink" title="继承方式4 - Object.create( 很少用 )"></a>继承方式4 - Object.create( 很少用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; value: 100 &#125;</div><div class="line">var newObj = Object.create(obj);</div></pre></td></tr></table></figure>
<h3 id="继承方式5-借用Object-create方法覆写显式原型-很少用"><a href="#继承方式5-借用Object-create方法覆写显式原型-很少用" class="headerlink" title="继承方式5 - 借用Object.create方法覆写显式原型( 很少用 )"></a>继承方式5 - 借用Object.create方法覆写显式原型( 很少用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj = &#123; value: 100 &#125;</div><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype = Object.create(obj);</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h3 id="继承方式6-复合式原型继承-很少用"><a href="#继承方式6-复合式原型继承-很少用" class="headerlink" title="继承方式6 - 复合式原型继承( 很少用 )"></a>继承方式6 - 复合式原型继承( 很少用 )</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function PrFn() &#123;&#125;</div><div class="line">PrFn.prototype.value = 100;</div><div class="line">function Fn() &#123;&#125;</div><div class="line">Fn.prototype = new PrFn()</div><div class="line">var fn = new Fn();</div></pre></td></tr></table></figure>
<h2 id="需求：让o2能够使用o对象里面的属性。"><a href="#需求：让o2能够使用o对象里面的属性。" class="headerlink" title="需求：让o2能够使用o对象里面的属性。"></a>需求：让o2能够使用o对象里面的属性。</h2><blockquote>
<p>可以考虑直接把o对象的属性和值copy到o2身上完成需求。<br> 这种方式，只是一个编程技巧，使用这个技巧完成的事情，<br> 让人从表面上感觉有继承的特性，所以很多地方称这个技巧为copy继承。<br> 以后我们称这种方式为混入  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var o = &#123; val: 100 &#125;;</div><div class="line">        var o2 = &#123; name: &apos;guo&apos; &#125;;</div><div class="line">        // 遍历o对象的属性和值</div><div class="line">        // copy到o2身上</div><div class="line">        for ( var key in o ) &#123;</div><div class="line">            o2[key] = o[key];</div><div class="line">        &#125;</div><div class="line">        console.log(o);</div><div class="line">        console.log(o2);</div></pre></td></tr></table></figure>
<h2 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h2><blockquote>
<p>可被遍历的，就叫枚举。<br>内置的属性不可枚举：<br> 浏览器内置的属性，无法使用for in遍历出来<br> 默认对象就可以使用一些方法，这些方法都是内置的<br> obj.toString();<br>obj.valueOf();</p>
</blockquote>
<h2 id="实例成员与静态成员"><a href="#实例成员与静态成员" class="headerlink" title="实例成员与静态成员"></a>实例成员与静态成员</h2><blockquote>
<p>添加给实例的属性或方法，就叫实例成员，<br> 添加给类(构造函数)自己的属性或方法，就叫类成员(静态成员)。</p>
</blockquote>
<h2 id="继承的规律："><a href="#继承的规律：" class="headerlink" title="继承的规律："></a>继承的规律：</h2><ol>
<li>对象继承的终点是Object.prototype</li>
<li>所有函数默认的显示原型（即函数的prototype） 都继承 Object.prototype</li>
<li>谁的实例，这个实例就继承谁的prototype<ol>
<li>所有的函数，都被看作是Function的实例，所以都继承 </li>
<li>所有的数组，都被看作是Array的实例，所以都继承 Array.prototype</li>
<li>所有的正则，都被看作是RegExp的实例，所以都继承 RegExp.prototype</li>
</ol>
</li>
</ol>
<p><strong>Math直接继承object.prototype</strong></p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><blockquote>
<p>一个对象所继承的那些对象，都可以称之为这个对象的原型对象。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>一个对象继承的所有对象  被形象的称之为  对象的原型链。#</p>
</blockquote>
<h2 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h2><blockquote>
<p>可以遍历一个对象的继承属性（对象必须是可以枚举的）</p>
</blockquote>
<h2 id="静态成员-类成员"><a href="#静态成员-类成员" class="headerlink" title="静态成员(类成员)"></a>静态成员(类成员)</h2><blockquote>
<p>添加给类(构造函数)自己的属性和方法，称之为静态成员。<br>静态成员的特点是，不需要创建实例即可通过类调用。</p>
</blockquote>
<h2 id="实例成员"><a href="#实例成员" class="headerlink" title="实例成员"></a>实例成员</h2><blockquote>
<p>添加给实例的属性和方法，称之为实例成员。<br>添加到原型中的属性与方法，本意是让实例使用的，所以也可以理解为是实例成员<br><em>实例成员不能使用类成员的属性和方法</em></p>
</blockquote>
<h2 id="Object-prototype上面的几个方法"><a href="#Object-prototype上面的几个方法" class="headerlink" title="Object.prototype上面的几个方法"></a>Object.prototype上面的几个方法</h2><h3 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty"></a>hasOwnProperty</h3><blockquote>
<p>作用：判断一个对象是否(自己)含有某个属性<br>语法: 对象.hasOwnProperty( 要判断的属性名 )<br>返回值：boolean</p>
<h3 id="propertyIsEnumerable-NaN"><a href="#propertyIsEnumerable-NaN" class="headerlink" title="propertyIsEnumerable"></a>propertyIsEnumerable</h3><p>作用：判断一个对象是否(自己)含有某个属性，并且还要判断这个属性是不是可枚举的，<br>这个方法是一个双重判断，通常称这个方法为hasOwnProperty的加强版。<br>语法: 对象.propertyIsEnumerable( 要判断的属性名 )<br> 返回值：boolean</p>
<h3 id="isPrototypeOf-NaN"><a href="#isPrototypeOf-NaN" class="headerlink" title="isPrototypeOf"></a>isPrototypeOf</h3><p>作用：判断一个对象是不是另一个对象的原型对象<br>语法：被判断的对象.isPrototypeOf( 对象 )<br>返回值：boolean</p>
<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h3><p>作用：根据方法执行时内部的this指向，<br>返回一个类似于这样的字符串：’[object this对象的类型名称]’，<br>通过这个字符串，可以得知内置对象的类型。</p>
</blockquote>
<h2 id="函数的几个属性介绍"><a href="#函数的几个属性介绍" class="headerlink" title="函数的几个属性介绍"></a>函数的几个属性介绍</h2><blockquote>
<p>arguments 代表实参的伪数组对象，之前arguments是函数的属性，需要通过(函数.arguments使用)。<br>但是被废除了，arguments已经是关键字了，可以直接使用，就像this那样。<br>caller 返回调用该函数的函数<br>length 形参的个数<br>name 函数的名字<br>arguments 有一个callee属性，该属性返回被调用的函数。说白一点，callee就是返回函数自己</p>
</blockquote>
<h2 id="in运算符"><a href="#in运算符" class="headerlink" title="in运算符"></a>in运算符</h2><blockquote>
<p>判断一个对象能否使用某个属性。<br>语法：’属性名’  in  对象<br>返回值：boolean</p>
</blockquote>
<h2 id="delete运算符："><a href="#delete运算符：" class="headerlink" title="delete运算符："></a>delete运算符：</h2><blockquote>
<p>用：删除对象的属性。<br>语法：delete 对象.属性名</p>
</blockquote>
<h2 id="Function创建函数的语法"><a href="#Function创建函数的语法" class="headerlink" title="Function创建函数的语法"></a>Function创建函数的语法</h2><blockquote>
<p>ew Function( arg_name1, arg_name2, arg_name3, functionBody )<br>前面可以定义任意数量的形参，最后一个参数代表函数的代码体。<br>注意：这些参数必须是字符串的形式。<br>返回值：一个新创建的函数实例。</p>
</blockquote>
<h2 id="eval可以直接把字符串当做代码执行"><a href="#eval可以直接把字符串当做代码执行" class="headerlink" title="eval可以直接把字符串当做代码执行"></a>eval可以直接把字符串当做代码执行</h2><blockquote>
<p>语法：eval(字符串代码)</p>
</blockquote>
<h2 id="JSON数据格式-gt-‘-“name”-“李四”-’"><a href="#JSON数据格式-gt-‘-“name”-“李四”-’" class="headerlink" title="JSON数据格式 ==&gt;   ‘{ “name”: “李四” }’"></a>JSON数据格式 ==&gt;   ‘{ “name”: “李四” }’</h2><blockquote>
<p>为了方便操作JSON数据，ES5提供了JSON对象，里面有两个方法。<br>JSON.parse ： 用来把JSON数据转换为js对象<br>JSON.stringify : 用来把js对象转换为JSON数据<br>在ie8之前，可以用过eval或者Function解析JSON数据。<br>console.log(eval(‘(‘+JSONString+’)’));</p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote>
<p>代码块就是一对大括号，里面可以写任意代码；<br>如果想要js把大括号当做对象解析，那么需要把大括号放入表达式中使用。<br>直接使用大括号，就是代码块<br>{var a = 1;console.log(a);}<br>放入表达式中，就是对象<br>var a = {};</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/17/ziliao/" data-id="ciudfedt20001p0qm06xdk0o4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/13/hello-world/" class="article-date">
  <time datetime="2016-10-12T16:36:15.070Z" itemprop="datePublished">2016-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/13/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/10/13/hello-world/" data-id="ciudfedst0000p0qmt12eyqkn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/17/ziliao/">ziliao</a>
          </li>
        
          <li>
            <a href="/2016/10/13/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 JIAO GUOWEI<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>